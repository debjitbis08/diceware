<div id="random-string-output" x-data="stringOutput" :class="{ hidden: rollValues.length === 0 || type !== 'string' }">
    <h2 id="string-output-header" class="text-xl font-bold mb-2">Random String</h2>

    <div class="bg-gray-100 dark:bg-gray-900 p-4 rounded-lg shadow-inner">
        <div class="relative mb-2 flex items-center">
            <p id="generated-string" class="flex-1 text-blue-600 dark:text-blue-400 font-mono" x-text="generatedString"></p>
            <button
                class="text-black bg-gray-300 hover:bg-gray-400 text-xs py-1 px-2 ml-2 rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                @click="copyToClipboard('generated-string')"
            >
            Copy
            </button>
        </div>
    </div>
</div>

<script>
import Alpine from "alpinejs";

document.addEventListener('alpine:init', () => {
  Alpine.data('stringOutput', () => ({
    generatedString: '',

    init() {
      Alpine.effect(() => {
        if (this.type !== 'string') return;

        this.generatedString = convertDiceRollsToRandomString(this.rollValues, this.byteLength * 8);

      });
    }
  }));
});

function convertDiceRollsToRandomString(diceRolls, targetEntropy, outputFormat = 'base64') {
  let binaryString = '';

  // Convert each roll result into its binary representation
  diceRolls.forEach(roll => {
    roll.forEach(diceValue => {
      const binary = (diceValue - 1).toString(2).padStart(3, '0'); // 3 bits for each dice (since 6 dice values = 2^3 = 8 possibilities)
      binaryString += binary;
    });
  });

  // Ensure we have exactly enough bits (targetEntropy) by trimming or adding more rolls
  binaryString = binaryString.slice(0, targetEntropy); // Slice to the target entropy bits

  // Convert the binary string into bytes
  const byteLength = Math.ceil(binaryString.length / 8);
  const byteArray = new Uint8Array(byteLength);

  for (let i = 0; i < byteLength; i++) {
    byteArray[i] = parseInt(binaryString.slice(i * 8, (i + 1) * 8), 2);
  }

  // Convert byte array to Base64 or Hex
  if (outputFormat === 'base64') {
    return btoa(String.fromCharCode.apply(null, byteArray)); // Base64 encoding
  } else if (outputFormat === 'hex') {
    return Array.from(byteArray)
      .map(byte => byte.toString(16).padStart(2, '0'))
      .join(''); // Hex encoding
  }

  return '';
}
</script>
